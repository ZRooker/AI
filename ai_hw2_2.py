# -*- coding: utf-8 -*-
"""AI_HW2_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QsHx9nHW6vsXvXT-QmywkfM6X1kxrmWS
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import numpy as np
import matplotlib.pyplot as plt
import random
import itertools

#Number of Cities
N = 100

#coordinates of the cities in 2x20 matrix
coordinates_matrix = np.array([41,25, 20, 10, 45, 45, 31, 2, 42, 2, 49, 53, 12, 49, 57, 49, 55, 4, 15, 22, 35, 35, 20, 50, 5, 45, 35, 35, 20, 24, 8, 27, 32, 24, 67, 47, 53, 15, 28, 22, 25, 55, 10, 30, 20, 55, 41, 53, 5, 23, 13, 37, 36, 27, 56, 44, 61, 14, 26, 18, 19, 55, 55, 15, 15, 65, 64, 65, 60, 11, 6, 57, 21, 15, 37, 46, 57, 11, 26, 26, 20, 15, 30, 30, 45, 65, 40, 63, 40, 6, 47, 63, 17, 62, 37, 49, 56, 16, 31, 25, 18]),([49, 30, 65, 20, 20, 30, 52, 60, 7, 48, 58, 12, 24, 73, 68, 42, 54, 18, 19, 27, 35, 17, 50, 35, 30, 10, 40, 69, 20, 12, 56, 43, 12, 58, 5, 16, 43, 47, 18, 22, 21, 45, 43, 25, 40, 5, 37, 52, 5, 3, 52, 31, 26, 69, 39, 17, 52, 37, 52, 24, 21, 20, 60, 10, 60, 35, 42, 55, 12, 14, 68, 29, 24, 77, 47, 13, 48, 31, 35, 27, 26, 30, 60, 5, 65, 20, 60, 65, 25, 38, 47, 23, 34, 77, 56, 11, 37, 22, 67, 24, 18])
                                  #Getting the coordinates into one matrix
cord = []
for i in range(N):
  city = i
  x = coordinates_matrix[0][i]
  y = coordinates_matrix[1][i]
  cord.append([x,y])

#Cordinates now holds the x and y values in the matrix
coordinates = np.array(cord)
print(coordinates)

dist_matrix = np.zeros((N,N))
for i in range(N):
  for j in range(N):
    x1 = coordinates[i,0]
    y1 = coordinates[i,1]
    x2 = coordinates[j,0]
    y2 = coordinates[j,1]

    if x1 -x2 == 0 and y1 - y2 == 0: 
      dist_matrix[i,j] = 1000    #Assigning large value to get out of the way
    else: 
      dist_matrix[i,j] = np.sqrt((x1-x2)**2+(y1-y2)**2)

#Print the matrix of distances between the cities
print(dist_matrix)

      #print("The distance between cities", i+1, "and", j+1, "is", euclid_dist(coordinates[i], coordinates[j]))

for i in range(N):
  plt.title('City Locations')
  plt.xlabel('x coordinates')
  plt.ylabel('y coordinates')
  plt.plot(coordinates[i][0],coordinates[i][1], marker="o", markersize=10, markeredgecolor="red", markerfacecolor="blue")

from IPython.core.display import os
def SimulatedAnnealing(T,alpha):
  #Generate a random initial solution
  currentSolution = np.random.permutation(N)
  
  #Calculate the cost of the initial solution
  currentCost = cost(currentSolution,dist_matrix)
  
  #Set best solution equal to initial solution
  bestSolution = currentSolution
  
  #Set best cost equal to initial cost
  bestCost = currentCost
  
  #Start annealing process
  while T > 1:
    
    #Generate a random neighbor
    newSolution = generateNeighbor(currentSolution,dist_matrix)
   
    #Calculate the cost of the new solution
    newCost = cost(newSolution,dist_matrix)
    
    #Decide if we should accept the new solution
    if acceptanceProbability(currentCost,newCost,T) > np.random.rand():
      currentSolution = newSolution
      currentCost = newCost
      
    #Keep track of the best solution
    if currentCost < bestCost:
      bestSolution = currentSolution
      bestCost = currentCost
      
    #Decrease the temperature
    T = T*alpha
    
  return bestSolution

#our cost function
def cost(solution,dist_matrix):
  total_cost = 0
  for i in range(N):
    j = (i+1)%N
    total_cost += dist_matrix[solution[i],solution[j]]
  return total_cost

#Generating a Neighbor
#def generateNeighbor(solution,dist_matrix):
#  new_solution = np.copy(solution)
#
#  for i in range(N):
#  #shortest_neighbor = min(dist_matrix[i])
#  #min_val, min_pos = min((val, idx) for (idx, val) in np.ndenumerate(dist_matrix[i]))
#    min_index = np.argmin(dist_matrix[i])
#    #max_index = np.argmax(dist_matrix[i])
#  #coor = dist_matrix[i,min_index]
#  #shortest_position = dist_matrix.index(min(dist_matrix[i]))
#  #print(closest_city)
#  #print("The minimum value is", min_val, "at position", min_pos)
#  #l = np.random.randint(N)
#    if i == N-1:
#      new_solution[min_index],new_solution[0] = new_solution[0],new_solution[min_index]  #Ensuring that we are adding the initial city too
#    
#    else:
#      if min_index == new_solution[0]:
#        new_solution[min_index],new_solution[0] = new_solution[0],new_solution[min_index]
#      else: 
#        new_solution[min_index],new_solution[i+1] = new_solution[i+1],new_solution[min_index]
#    print(new_solution[0])
#  return new_solution

  #Generating a Neighbor
def generateNeighbor(solution,dist_matrix):
  new_solution = np.copy(solution)
  l = np.random.randint(N)
  m = (l+1)%N
  n = np.random.randint(N)
  o = (l+1)%N
  #p = np.random.randint(N)
  #q = (p+1)%N
  #r = np.random.randint(N)
  #s = (p+1)%N
  new_solution[l],new_solution[m] = new_solution[m],new_solution[l]
  new_solution[n],new_solution[o] = new_solution[o],new_solution[n]
  #new_solution[p],new_solution[q] = new_solution[q],new_solution[p]
  #new_solution[r],new_solution[s] = new_solution[s],new_solution[r]
  return new_solution

#Deciding the acceptance Probabilty 
def acceptanceProbability(cost,new_cost,T):
  if new_cost < cost:
    return 1
  else:
    return np.exp((cost-new_cost)/T)

#Parameters
T = 2
alpha = 0.999955
#Run Simulated Annealing
bestSolution = SimulatedAnnealing(T,alpha)
#Print the best solution
print("Best solution: ",bestSolution)
#Calculate the cost
bestCost = cost(bestSolution,dist_matrix)
#Print the best cost
print("Best cost: ",bestCost)
#Plot the best solution
bestSolution = np.append(bestSolution,bestSolution[0])
plt.title('Best Solution')
plt.xlabel('x coordinates')
plt.ylabel('y coordinates')
plt.plot(coordinates[bestSolution,0],coordinates[bestSolution,1],'-bo',coordinates[bestSolution,0],coordinates[bestSolution,1],'r-')
plt.show()