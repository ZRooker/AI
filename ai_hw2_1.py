# -*- coding: utf-8 -*-
"""AI_HW2_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YntbaznXAAM5nQBovGFbtkY1YwBq_Arv
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import numpy as np
import matplotlib.pyplot as plt
import random
import itertools

#Number of Cities
N = 20

#coordinates of the cities in 2x20 matrix
coordinates_matrix = np.array([0.6606,0.9695,0.5906,0.2124,0.0398,0.1367,0.9536,0.6091,0.8767,0.8148,0.3876,0.7041,0.0213,0.3429,0.7471,0.5449,0.9464,0.1246,0.1636,0.8668]),([0.95,0.674,0.5029,0.8274,0.9697,0.597,0.2184,0.7148,0.2395,0.2867,0.82,0.3296,0.1649,0.3025,0.8192,0.9392,0.8191,0.4351,0.8646,0.6768])

#Getting the coordinates into one matrix
cord = []
for i in range(N):
  city = i
  x = coordinates_matrix[0][i]
  y = coordinates_matrix[1][i]
  cord.append([x,y])

#Cordinates now holds the x and y values in the matrix
coordinates = np.array(cord)
print(coordinates)

dist_matrix = np.zeros((N,N))
for i in range(N):
  for j in range(N):
    x1 = coordinates[i,0]
    y1 = coordinates[i,1]
    x2 = coordinates[j,0]
    y2 = coordinates[j,1]
    dist_matrix[i,j] = np.sqrt((x1-x2)**2+(y1-y2)**2)

#Print the matrix of distances between the cities
print(dist_matrix)

      #print("The distance between cities", i+1, "and", j+1, "is", euclid_dist(coordinates[i], coordinates[j]))

for i in range(N):
  plt.title('City Locations')
  plt.xlabel('x coordinates')
  plt.ylabel('y coordinates')
  plt.plot(coordinates[i][0],coordinates[i][1], marker="o", markersize=10, markeredgecolor="red", markerfacecolor="blue")

def SimulatedAnnealing(T,alpha):
  #Generate a random initial solution
  currentSolution = np.random.permutation(N)
  
  #Calculate the cost of the initial solution
  currentCost = cost(currentSolution,dist_matrix)
  
  #Set best solution equal to initial solution
  bestSolution = currentSolution
  
  #Set best cost equal to initial cost
  bestCost = currentCost
  
  #Start annealing process
  while T > .001:
    
    #Generate a random neighbor
    newSolution = generateNeighbor(currentSolution,dist_matrix)
   
    #Calculate the cost of the new solution
    newCost = cost(newSolution,dist_matrix)
    
    #Decide if we should accept the new solution
    if acceptanceProbability(currentCost,newCost,T) > np.random.rand():
      currentSolution = newSolution
      currentCost = newCost
      
    #Keep track of the best solution
    if currentCost < bestCost:
      bestSolution = currentSolution
      bestCost = currentCost
      
    #Decrease the temperature
    T = T*alpha
    
  return bestSolution

#our cost function
def cost(solution,dist_matrix):
  total_cost = 0
  for i in range(N):
    j = (i+1)%N
    total_cost += dist_matrix[solution[i],solution[j]]
  return total_cost

#Generating a Neighbor
def generateNeighbor(solution,dist_matrix):
  new_solution = np.copy(solution)
  l = np.random.randint(N)
  m = (l+1)%N
  n = np.random.randint(N)
  o = (l+1)%N
  #p = np.random.randint(N)
  #q = (n+1)%N
  new_solution[l],new_solution[m] = new_solution[m],new_solution[l]
  new_solution[n],new_solution[o] = new_solution[o],new_solution[n]
  #new_solution[p],new_solution[q] = new_solution[q],new_solution[p]
  return new_solution

#Deciding the acceptance Probabilty 
def acceptanceProbability(cost,new_cost,T):
  if new_cost < cost:
    return 1
  else:
    return np.exp((cost-new_cost)/T)

#Parameters
T = 2
alpha = 0.9995
#Run Simulated Annealing
bestSolution = SimulatedAnnealing(T,alpha)
#Print the best solution
print("Best solution: ",bestSolution)
#Calculate the cost
bestCost = cost(bestSolution,dist_matrix)
#Print the best cost
print("Best cost: ",bestCost)
#Plot the best solution
bestSolution = np.append(bestSolution,bestSolution[0])
plt.title('Best Solution')
plt.xlabel('x coordinates')
plt.ylabel('y coordinates')
plt.plot(coordinates[bestSolution,0],coordinates[bestSolution,1],'-bo',coordinates[bestSolution,0],coordinates[bestSolution,1],'r-')
plt.show()